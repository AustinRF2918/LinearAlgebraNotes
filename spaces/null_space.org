* Null Space
** Relation To Subspace
   We can note that null *space* includes the word space in it: This is
   because on top of being a *subset* of some 

   #+BEGIN_SRC latex
    \begin{equation}\mathbb{R}^n\end{equation} 
   #+END_SRC
   
   It also has the following attributes where *u* and *v* exist such that:
   #+BEGIN_SRC latex
     \begin{equation}A\vec{u} = \vec{0}\end{equation}
     \begin{equation}A\vec{v} = \vec{0}\end{equation}
   #+END_SRC

      Due to these facts we know

    #+BEGIN_SRC latex
     \begin{equation}A\vec{0} = \vec{0}\end{equation}
     \begin{equation}A\vec{u + v} = A\vec{u} + V\vec{v} = \vec{0} + \vec{0} = \vec{0}\end{equation}
     \begin{equation}cA\vec{u} = c\vec{0}\end{equation}
     which in turn means
     \begin{equation}cA\vec{u} = \vec{0}\end{equation}
     which also means
     \begin{equation}Ac\vec{u} = \vec{0}\end{equation}
   #+END_SRC

   These three facts are the definition of a subspace, therefore we have shown
   why the null space is, in fact, a subspace.

* Explicit and Implicit Definitions
  An explicit definition of an idea can be thought of as a *defined trait bound*,
  something that at "compile time" can be checked for, on the other hand an
  implicit defition resembles what can be thought of as a *dynamic trait bound*,
  in which we check for some rule that may or may not pass at runtime: This can
  be thought of like so:

  #+BEGIN_SRC rust
    // An example of a defined trait bound in Rust.
    trait Shape {
      fn area(&self) -> f64,
      fn perimeter(&self) -> f64,
      fn sides(&self) -> u32,
    }
    
    // This may not be a realistic API, but it gets the point
    // across, now lets define a square structure.
    
    struct Square {
      area: f64
    }
    
    impl Shape for Square {
      fn area(&self) -> f64 {
        self.area
      }
      
      fn perimeter(&self) -> f64 {
        4 * Sqrt(area())
      }
      
      fn sides(&self) -> u32 {
        self.sides
      }
    }
    
    // Note that this structure is now static and sized in memory. Let's imagine
    // we  created a "runtime shape"
    
    struct RuntimeShape {
      // fields
    }
    
    fn is_square(s: &Shape) -> bool {
      s.sides() == 4 
    }
    
  #+END_SRC
  
  is_square shows a programmatic display of implicit definitions: Instead of 
  directly defining the trait on the structure, we allow static bounds to 
  be modified via mutability and then check as needed for the implicit 
  definition of square. This forces us to check that something fullfills 
  some attributes and is naturally slower. Using math, specifically with
  *Nul A* allows us to get an explicit definition of the solution of 
  a implicitly defined trait.
* Receiving Explicit Defintion Of Nul A Output
  This is a fairly simple algorithm: Here are the steps.
** Step 1
   First we must arrange our matrix to be of form:
   #+BEGIN_SRC latex
     \begin{equation}A\vec{u} = \vec{0}\end{equation}
   #+END_SRC
   
** Step 2
   Next, we must perform a row reduction algorithm upon
   the resultant matrix.
   
   #+BEGIN_SRC mathematica
     Reduce[x]
   #+END_SRC
   
** Step 3
   Once we have performed our reduce operation, we must 
   decompose our vectors using our free variables as 
   atomic weights upon the vectors, and our non-free
   variables in terms of where they appear.
   
** Step 4
   Once we perform all these operations, we can safely
   assume that all of the linear combinations of the
   decomposed units are parts of Nul A.
   
** Notes
*** Linear Independance
    Note that this resulting generator with {*u*, *v*, *w*},
    *u*, *v*, *w* will be linearly independant *UNLESS* *u*,
    *v*, and *w* are zero vectors. Aka, in this example
    *u*, *v*, and *w* all play unique roles in the vector function,
    so to say.

*** Spanning Set and Free Variables
    The amount of vectors in the resultant set will be 
    the number of free variables. This is clearly visible 
    in this example and will hold true to any number of
    free variables.

